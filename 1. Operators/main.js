
----------Задание 1.-------------

Посмотрите, понятно ли вам, почему код ниже работает именно так?

 var a = 1, b = 1, c, d;

c = ++a; alert(c); // 2
d = b++; alert(d); // 1

c = (2+ ++a); alert(c); // 5
d = (2+ b++); alert(d); // 4

alert(a); // 3
alert(b); // 3

            Ответ: 
1. Переменной c присвоено значение переменной а, преобразованное инкрементом.
Инкремент префиксной формы возвращает значение переменной а, увеличенное на единицу.
В результате с = 2, и а тоже будет равно 2.

2. Переменной d присвоено значение переменной b, преобразованное инкрементом.
Поскольку инкремент постфиксной формы, он сначала возвращает значение переменной b 
до увеличения, которое и присваивается переменной d. В результате d = 1, а вот b 
будет равно 2. 

3. Значение переменной с переопределяется. В выражении в скобках сначала срабатывает инкремент,
поскольку его приоритет выше приоритета бинарного плюса. Значение переменной а было 2.
Инкремент увеличил его на 1, т.е. а = 3. Далее выполняется сложение и его результат
записывается в переменную с. Поэтому с = 5.

4. В выражении в скобках инкремент постфиксной формы возвращает старое значение
переменной b, которое у нас было равно 2. Далеее выполняется обычное сложение, в результате
переменная d = 4. Сама же переменная b увеличивается и становится равна 3. 

5. Переменные а и b были увеличены 2 раза на единицу в результате выполнения вышеописанных операций.
Поэтому они равны 3.

--------------Задание 2--------------

Чему будет равен x в примере ниже?

var a = 2;

var x = 1 + (a *= 2);

               Ответ:
              
х = 5. Выражние в скобках можно еще записать так: a = a * 2;
В результате переменная а = 4, а х = 5.



ЛОГИЧЕСКИЕ ОПЕРАТОРЫ

--------------Задание 1---------------

Что выведет код ниже?

alert( null || 2 || undefined );

Ответ: 2. Вычисление остановится на первом true и выведется именно это значение.

--------------Задание 2----------------

Что выведет код ниже?

alert( alert(1) || 2 || alert(3) );

Ответ: 1 и 2. Сначала выполнится вызов alert(1), который выведет на экран 1 и вернет
значение undefined. Потом внешний вызов alert выведет на экран первое истинное значение (2).
До вызова alert(3) дело просто не дойдёт.

--------------Задание 3----------------

Что выведет код ниже?

alert( 1 && null && 2 );

Ответ: null. Оператор && вычисляет все аргументы слева направо и возвращает первое ложное.

-------------Задание 4-----------------

Что выведет код ниже?

alert( alert(1) && alert(2) );

Ответ: 1 и undefined. Сначала выполнится alert(1), который выведет на экран 1 и вернет
значение undefined. Undefined при преобразовании к логическому типу эквивалентно false. 
Поскольку оператор && доходит до первого ложного значения и возвращает его, то на экран 
выведется undefined. А вызов alert(2) не выполнится.

-------------Задание 5-----------------

Что выведет код ниже?

alert( null || 2 && 3 || 4 );

Ответ: 3. Сначала выполнится оператор &&, приоритет которого выше. Поскольку оба значения истинны, то 
оператор вернет последнее значение 3. Потом будет выполняться оператор ||, который выведет первое 
истинное значение в цепочке null || 3 || 4 , то есть 3. 

--------------Задание 6------------------

Напишите условие if для проверки того факта, что переменная age находится между 14 и 90 включительно.

«Включительно» означает, что концы промежутка включены, то есть age может быть равна 14 или 90.

Ответ:  let age = 50;

if (age >= 14 && age <= 90) {
  alert('Что-нибудь!');
}

----------------Задание 7-------------------

Напишите условие if для проверки того факта, что age НЕ находится между 14 и 90 включительно.

Сделайте два варианта условия: первый с использованием оператора НЕ !, второй – без этого оператора.

Ответ: 1.let age = 50;

if (!(age >= 14 && age <= 90)) {
  alert('Что-нибудь!');
}

2. let age = 50;

if (age < 14 || age > 90) {
  alert('Что-нибудь');
}

-----------------Задание 8--------------------

Какие из этих if верны, т.е. выполнятся?

Какие конкретно значения будут результатами выражений в условиях if(...)?

if (-1 || 0) alert( 'первое' );
if (-1 && 0) alert( 'второе' );
if (null || -1 && 1) alert( 'третье' );

Ответ: Первое выражение выполнится, при проверке оператором || значение -1 приравнивается к 
логическому true. Значит все выражение в скобках будет true и выполнится вызов alert('первое').

Второе выражение не выполнится. В скобках общее значение будет false, т.к. одно из значений
(0) равен false.

Третье выражение выполнится. Оператор && вернет последнее истинное значение, т.е. 1. 
Далее будет выполняться оператор ||. Поскольку 1 это логическое true, то общее значение
выражения в скобках будет также истинно. и выполнится alert('третье').

ПРЕОБРАЗОВАНИЕ ТИПОВ ДЛЯ ПРИМИТИВОВ

-------------------Задание 1--------------------

Подумайте, какой результат будет у выражений ниже. 

"" + 1 + 0          /* строка "10", так как произойдет преобразование операндов к строчному типу и конкатенация */ 

"" - 1 + 0         /* -1, все приводится к численному типу и выполняются просто математические вычисления*/

true + false       /* 1, true приводится к 1, false - к 0, а 0+1=1 */

6 / "3"            /* 2, операнды приводятся к численному типу */

"2" * "3"          /* 6, операнды приводятся к численному типу */

4 + 5 + "px"       /* строка "9рх", сначала выполнится сложение 4+5, потом результат приведется к строчному типу и конкатенируется со строкой                          "рх" */

"$" + 4 + 5         /* строка "$45", операции будут выполняться слева направо, сначала приведется к строчному типу 4 и конкатенируется
                    с "$", потом 5 будет преобразована в строку и обїединена с "$4".  */

"4" - 2             /* 2, минус не преобразует к строчному типу, строка будет преобразована к числу 4, а далее выполнится вычитание. */

"4px" - 2           /* NaN, в результате преобразования к числу строки "4px" получится NaN, и вдальнейшем любые математические
                      действия с NaN тоже дадут NaN.  */

7 / 0               /* Infinity, в Джаваскрипте результатом деления на 0 не будет ошибка, получится бесконечность. */

"  -9\n" + 5        /* Строка "  -9\n5", преобразование к строчному типу и конкатенация. */

"  -9\n" - 5        /* -14, строка преобразуется к числу -9, а дальше обычная математика. */ 

5 && 2              /* 2, оператор && вернет последнее истинное значение. */

2 && 5              /* 5, оператор && вернет последнее истинное значение. */

5 || 0              /* 5, оператор || вернет первое истинное значение. */

0 || 5              /* 5, оператор || вернет первое истинное значение. */

null + 1            /* 1, null преобразовывается в 0, а 0+1=1. */

undefined + 1       /* NaN, undefined преобразуется в NaN, а любые операции с NaN тоже дадут NaN. */

null == "\n0\n"     /* false, так так null равно только undefined */.

+null == +"\n0\n"  /* true, обе части равенства будут преобразованы к числу 0 == 0.  */.



